/*
 * Copyright 2014-2025 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.
 */

package io.ktor.client.webrtc

import io.ktor.utils.io.core.Closeable
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asSharedFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import kotlin.coroutines.CoroutineContext

public sealed interface TrackEvent {
    public val track: WebRtcMedia.Track

    /**
     * Event emitted when the track is added to the connection.
     */
    public class Add(override val track: WebRtcMedia.Track) : TrackEvent

    /**
     * Event emitted when the track is removed from the connection by the other peer.
     * This is different from MediaStreamTrack's `ended` event.
     */
    public class Remove(override val track: WebRtcMedia.Track) : TrackEvent
}

/**
 * Abstract class representing a peer-to-peer connection.
 *
 * @param config Configuration for the peer connection.
 *
 * @see <a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection">MDN RTCPeerConnection</a>
 */
public abstract class WebRtcPeerConnection(
    override val coroutineContext: CoroutineContext,
    config: WebRtcConnectionConfig
) : CoroutineScope, Closeable {

    init {
        if (config.statsRefreshRate > 0) {
            launch {
                while (true) {
                    delay(config.statsRefreshRate)
                    statsFlow.emit(getStatistics())
                }
            }
        }
    }

    private val statsFlow: MutableStateFlow<List<WebRtc.Stats>> = MutableStateFlow(listOf())

    /**
     * Flow of connection statistics.
     */
    public val stats: StateFlow<List<WebRtc.Stats>> = statsFlow.asStateFlow()

    protected abstract suspend fun getStatistics(): List<WebRtc.Stats>

    private val iceCandidatesFlow: MutableSharedFlow<WebRtc.IceCandidate> =
        MutableSharedFlow(config.iceCandidatesReplay)

    /**
     * Flow of ICE candidates generated by this peer connection.
     */
    public val iceCandidates: SharedFlow<WebRtc.IceCandidate> = iceCandidatesFlow.asSharedFlow()

    private val iceConnectionStateFlow: MutableStateFlow<WebRtc.IceConnectionState> =
        MutableStateFlow(WebRtc.IceConnectionState.NEW)

    /**
     * Flow of ICE connection state changes.
     */
    public val iceConnectionState: StateFlow<WebRtc.IceConnectionState> = iceConnectionStateFlow.asStateFlow()

    private val connectionStateFlow: MutableStateFlow<WebRtc.ConnectionState> =
        MutableStateFlow(WebRtc.ConnectionState.NEW)

    /**
     * Flow of connection state changes.
     */
    public val state: StateFlow<WebRtc.ConnectionState> = connectionStateFlow.asStateFlow()

    private val iceGatheringStateFlow: MutableStateFlow<WebRtc.IceGatheringState> =
        MutableStateFlow(WebRtc.IceGatheringState.NEW)

    /**
     * Flow of ICE gathering state changes.
     */
    public val iceGatheringState: StateFlow<WebRtc.IceGatheringState> = iceGatheringStateFlow.asStateFlow()

    private val signalingStateFlow: MutableStateFlow<WebRtc.SignalingState> =
        MutableStateFlow(WebRtc.SignalingState.STABLE)

    /**
     * Flow of signaling state changes.
     */
    public val signalingState: StateFlow<WebRtc.SignalingState> = signalingStateFlow.asStateFlow()

    private val trackEventsFlow: MutableSharedFlow<TrackEvent> = MutableSharedFlow(config.remoteTracksReplay)

    /**
     * Flow of remote track events (add/remove).
     */
    public val trackEvents: SharedFlow<TrackEvent> = trackEventsFlow.asSharedFlow()

    /**
     * The local session description for this connection.
     */
    public abstract val localDescription: WebRtc.SessionDescription?

    /**
     * The remote session description for this connection.
     */
    public abstract val remoteDescription: WebRtc.SessionDescription?

    protected var negotiationNeededCallback: (() -> Unit) = {}

    /**
     * Creates an SDP offer for establishing a connection.
     *
     * @return The session description representing the offer.
     */
    public abstract suspend fun createOffer(): WebRtc.SessionDescription

    /**
     * Creates an SDP answer in response to a received offer.
     *
     * @return The session description representing the answer.
     */
    public abstract suspend fun createAnswer(): WebRtc.SessionDescription

    /**
     * Sets the local session description.
     */
    public abstract suspend fun setLocalDescription(description: WebRtc.SessionDescription)

    /**
     * Sets the remote session description.
     */
    public abstract suspend fun setRemoteDescription(description: WebRtc.SessionDescription)

    /**
     * Adds a remote ICE candidate to this connection.
     */
    public abstract suspend fun addIceCandidate(candidate: WebRtc.IceCandidate)

    /**
     * Adds a media track to this connection.
     *
     * @param track The media track to add.
     * @return An RTP sender for the added track.
     */
    public abstract suspend fun addTrack(track: WebRtcMedia.Track): WebRtc.RtpSender

    /**
     * Removes a track from this connection using its RTP sender.
     *
     * @param sender The RTP sender for the track to remove.
     */
    public abstract suspend fun removeTrack(sender: WebRtc.RtpSender)

    /**
     * Removes a track from this connection.
     *
     * @param track The media track to remove.
     */
    public abstract suspend fun removeTrack(track: WebRtcMedia.Track)

    /**
     * Restarts ICE negotiation for this connection.
     * Should trigger `onNegotiationNeeded` callback.
     * The next offer will be created with `iceRestart` option.
     */
    public abstract fun restartIce()

    /**
     * Sets a callback to be invoked when negotiation (offer-answer exchange, etc.) is needed for this connection.
     */
    public fun onNegotiationNeeded(callback: () -> Unit) {
        negotiationNeededCallback = callback
    }

    protected fun onIceCandidate(candidate: WebRtc.IceCandidate) {
        launch { iceCandidatesFlow.emit(candidate) }
    }

    protected fun onIceConnectionStateChange(state: WebRtc.IceConnectionState) {
        launch { iceConnectionStateFlow.emit(state) }
    }

    protected fun onConnectionStateChange(state: WebRtc.ConnectionState) {
        launch { connectionStateFlow.emit(state) }
    }

    protected fun onIceGatheringStateChange(state: WebRtc.IceGatheringState) {
        launch { iceGatheringStateFlow.emit(state) }
    }

    protected fun onSignalingStateChange(state: WebRtc.SignalingState) {
        launch { signalingStateFlow.emit(state) }
    }

    protected fun onAddTrack(track: WebRtcMedia.Track) {
        launch { trackEventsFlow.emit(TrackEvent.Add(track)) }
    }

    protected fun onRemoveTrack(track: WebRtcMedia.Track) {
        launch { trackEventsFlow.emit(TrackEvent.Remove(track)) }
    }
}
