// Klib ABI Dump
// Targets: [js]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <io.ktor:ktor-client-webrtc>
abstract interface <#A: out io.ktor.client.webrtc/WebRTCConfig> io.ktor.client.webrtc/WebRTCClientEngineFactory { // io.ktor.client.webrtc/WebRTCClientEngineFactory|null[0]
    abstract fun create(kotlin/Function1<#A, kotlin/Unit> = ...): io.ktor.client.webrtc/WebRTCEngine // io.ktor.client.webrtc/WebRTCClientEngineFactory.create|create(kotlin.Function1<1:0,kotlin.Unit>){}[0]
}

abstract interface io.ktor.client.webrtc/MediaTrackFactory { // io.ktor.client.webrtc/MediaTrackFactory|null[0]
    abstract suspend fun createAudioTrack(io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints): io.ktor.client.webrtc/WebRTCMedia.AudioTrack // io.ktor.client.webrtc/MediaTrackFactory.createAudioTrack|createAudioTrack(io.ktor.client.webrtc.WebRTCMedia.AudioTrackConstraints){}[0]
    abstract suspend fun createVideoTrack(io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints): io.ktor.client.webrtc/WebRTCMedia.VideoTrack // io.ktor.client.webrtc/MediaTrackFactory.createVideoTrack|createVideoTrack(io.ktor.client.webrtc.WebRTCMedia.VideoTrackConstraints){}[0]
}

abstract interface io.ktor.client.webrtc/WebRTCEngine : io.ktor.client.webrtc/MediaTrackFactory, io.ktor.utils.io.core/Closeable, kotlinx.coroutines/CoroutineScope { // io.ktor.client.webrtc/WebRTCEngine|null[0]
    abstract val config // io.ktor.client.webrtc/WebRTCEngine.config|{}config[0]
        abstract fun <get-config>(): io.ktor.client.webrtc/WebRTCConfig // io.ktor.client.webrtc/WebRTCEngine.config.<get-config>|<get-config>(){}[0]
    abstract val dispatcher // io.ktor.client.webrtc/WebRTCEngine.dispatcher|{}dispatcher[0]
        abstract fun <get-dispatcher>(): kotlinx.coroutines/CoroutineDispatcher // io.ktor.client.webrtc/WebRTCEngine.dispatcher.<get-dispatcher>|<get-dispatcher>(){}[0]

    abstract suspend fun createPeerConnection(): io.ktor.client.webrtc/WebRtcPeerConnection // io.ktor.client.webrtc/WebRTCEngine.createPeerConnection|createPeerConnection(){}[0]
}

abstract class io.ktor.client.webrtc/WebRTCEngineBase : io.ktor.client.webrtc/WebRTCEngine { // io.ktor.client.webrtc/WebRTCEngineBase|null[0]
    constructor <init>(kotlin/String) // io.ktor.client.webrtc/WebRTCEngineBase.<init>|<init>(kotlin.String){}[0]

    open val coroutineContext // io.ktor.client.webrtc/WebRTCEngineBase.coroutineContext|{}coroutineContext[0]
        open fun <get-coroutineContext>(): kotlin.coroutines/CoroutineContext // io.ktor.client.webrtc/WebRTCEngineBase.coroutineContext.<get-coroutineContext>|<get-coroutineContext>(){}[0]
    open val dispatcher // io.ktor.client.webrtc/WebRTCEngineBase.dispatcher|{}dispatcher[0]
        open fun <get-dispatcher>(): kotlinx.coroutines/CoroutineDispatcher // io.ktor.client.webrtc/WebRTCEngineBase.dispatcher.<get-dispatcher>|<get-dispatcher>(){}[0]

    open fun close() // io.ktor.client.webrtc/WebRTCEngineBase.close|close(){}[0]
}

abstract class io.ktor.client.webrtc/WebRtcPeerConnection : io.ktor.utils.io.core/Closeable { // io.ktor.client.webrtc/WebRtcPeerConnection|null[0]
    constructor <init>(kotlin/Int, kotlin/Int) // io.ktor.client.webrtc/WebRtcPeerConnection.<init>|<init>(kotlin.Int;kotlin.Int){}[0]

    abstract val localDescription // io.ktor.client.webrtc/WebRtcPeerConnection.localDescription|{}localDescription[0]
        abstract fun <get-localDescription>(): io.ktor.client.webrtc/WebRTC.SessionDescription? // io.ktor.client.webrtc/WebRtcPeerConnection.localDescription.<get-localDescription>|<get-localDescription>(){}[0]
    abstract val remoteDescription // io.ktor.client.webrtc/WebRtcPeerConnection.remoteDescription|{}remoteDescription[0]
        abstract fun <get-remoteDescription>(): io.ktor.client.webrtc/WebRTC.SessionDescription? // io.ktor.client.webrtc/WebRtcPeerConnection.remoteDescription.<get-remoteDescription>|<get-remoteDescription>(){}[0]
    final val connectionStateFlow // io.ktor.client.webrtc/WebRtcPeerConnection.connectionStateFlow|{}connectionStateFlow[0]
        final fun <get-connectionStateFlow>(): kotlinx.coroutines.flow/StateFlow<io.ktor.client.webrtc/WebRTC.ConnectionState> // io.ktor.client.webrtc/WebRtcPeerConnection.connectionStateFlow.<get-connectionStateFlow>|<get-connectionStateFlow>(){}[0]
    final val currentConnectionState // io.ktor.client.webrtc/WebRtcPeerConnection.currentConnectionState|{}currentConnectionState[0]
        final fun <get-currentConnectionState>(): kotlinx.coroutines.flow/MutableStateFlow<io.ktor.client.webrtc/WebRTC.ConnectionState> // io.ktor.client.webrtc/WebRtcPeerConnection.currentConnectionState.<get-currentConnectionState>|<get-currentConnectionState>(){}[0]
    final val currentIceConnectionState // io.ktor.client.webrtc/WebRtcPeerConnection.currentIceConnectionState|{}currentIceConnectionState[0]
        final fun <get-currentIceConnectionState>(): kotlinx.coroutines.flow/MutableStateFlow<io.ktor.client.webrtc/WebRTC.IceConnectionState> // io.ktor.client.webrtc/WebRtcPeerConnection.currentIceConnectionState.<get-currentIceConnectionState>|<get-currentIceConnectionState>(){}[0]
    final val currentIceGatheringState // io.ktor.client.webrtc/WebRtcPeerConnection.currentIceGatheringState|{}currentIceGatheringState[0]
        final fun <get-currentIceGatheringState>(): kotlinx.coroutines.flow/MutableStateFlow<io.ktor.client.webrtc/WebRTC.IceGatheringState> // io.ktor.client.webrtc/WebRtcPeerConnection.currentIceGatheringState.<get-currentIceGatheringState>|<get-currentIceGatheringState>(){}[0]
    final val currentSignalingState // io.ktor.client.webrtc/WebRtcPeerConnection.currentSignalingState|{}currentSignalingState[0]
        final fun <get-currentSignalingState>(): kotlinx.coroutines.flow/MutableStateFlow<io.ktor.client.webrtc/WebRTC.SignalingState> // io.ktor.client.webrtc/WebRtcPeerConnection.currentSignalingState.<get-currentSignalingState>|<get-currentSignalingState>(){}[0]
    final val currentStats // io.ktor.client.webrtc/WebRtcPeerConnection.currentStats|{}currentStats[0]
        final fun <get-currentStats>(): kotlinx.coroutines.flow/MutableStateFlow<kotlin.collections/List<io.ktor.client.webrtc/WebRTC.Stats>> // io.ktor.client.webrtc/WebRtcPeerConnection.currentStats.<get-currentStats>|<get-currentStats>(){}[0]
    final val iceCandidateFlow // io.ktor.client.webrtc/WebRtcPeerConnection.iceCandidateFlow|{}iceCandidateFlow[0]
        final fun <get-iceCandidateFlow>(): kotlinx.coroutines.flow/SharedFlow<io.ktor.client.webrtc/WebRTC.IceCandidate> // io.ktor.client.webrtc/WebRtcPeerConnection.iceCandidateFlow.<get-iceCandidateFlow>|<get-iceCandidateFlow>(){}[0]
    final val iceCandidates // io.ktor.client.webrtc/WebRtcPeerConnection.iceCandidates|{}iceCandidates[0]
        final fun <get-iceCandidates>(): kotlinx.coroutines.flow/MutableSharedFlow<io.ktor.client.webrtc/WebRTC.IceCandidate> // io.ktor.client.webrtc/WebRtcPeerConnection.iceCandidates.<get-iceCandidates>|<get-iceCandidates>(){}[0]
    final val iceConnectionStateFlow // io.ktor.client.webrtc/WebRtcPeerConnection.iceConnectionStateFlow|{}iceConnectionStateFlow[0]
        final fun <get-iceConnectionStateFlow>(): kotlinx.coroutines.flow/StateFlow<io.ktor.client.webrtc/WebRTC.IceConnectionState> // io.ktor.client.webrtc/WebRtcPeerConnection.iceConnectionStateFlow.<get-iceConnectionStateFlow>|<get-iceConnectionStateFlow>(){}[0]
    final val iceGatheringStateFlow // io.ktor.client.webrtc/WebRtcPeerConnection.iceGatheringStateFlow|{}iceGatheringStateFlow[0]
        final fun <get-iceGatheringStateFlow>(): kotlinx.coroutines.flow/StateFlow<io.ktor.client.webrtc/WebRTC.IceGatheringState> // io.ktor.client.webrtc/WebRtcPeerConnection.iceGatheringStateFlow.<get-iceGatheringStateFlow>|<get-iceGatheringStateFlow>(){}[0]
    final val remoteTracks // io.ktor.client.webrtc/WebRtcPeerConnection.remoteTracks|{}remoteTracks[0]
        final fun <get-remoteTracks>(): kotlinx.coroutines.flow/MutableSharedFlow<io.ktor.client.webrtc/Operation<io.ktor.client.webrtc/WebRTCMedia.Track>> // io.ktor.client.webrtc/WebRtcPeerConnection.remoteTracks.<get-remoteTracks>|<get-remoteTracks>(){}[0]
    final val remoteTracksFlow // io.ktor.client.webrtc/WebRtcPeerConnection.remoteTracksFlow|{}remoteTracksFlow[0]
        final fun <get-remoteTracksFlow>(): kotlinx.coroutines.flow/SharedFlow<io.ktor.client.webrtc/Operation<io.ktor.client.webrtc/WebRTCMedia.Track>> // io.ktor.client.webrtc/WebRtcPeerConnection.remoteTracksFlow.<get-remoteTracksFlow>|<get-remoteTracksFlow>(){}[0]
    final val signalingStateFlow // io.ktor.client.webrtc/WebRtcPeerConnection.signalingStateFlow|{}signalingStateFlow[0]
        final fun <get-signalingStateFlow>(): kotlinx.coroutines.flow/StateFlow<io.ktor.client.webrtc/WebRTC.SignalingState> // io.ktor.client.webrtc/WebRtcPeerConnection.signalingStateFlow.<get-signalingStateFlow>|<get-signalingStateFlow>(){}[0]
    final val statsFlow // io.ktor.client.webrtc/WebRtcPeerConnection.statsFlow|{}statsFlow[0]
        final fun <get-statsFlow>(): kotlinx.coroutines.flow/StateFlow<kotlin.collections/List<io.ktor.client.webrtc/WebRTC.Stats>> // io.ktor.client.webrtc/WebRtcPeerConnection.statsFlow.<get-statsFlow>|<get-statsFlow>(){}[0]

    final var negotiationNeededCallback // io.ktor.client.webrtc/WebRtcPeerConnection.negotiationNeededCallback|{}negotiationNeededCallback[0]
        final fun <get-negotiationNeededCallback>(): kotlin/Function0<kotlin/Unit> // io.ktor.client.webrtc/WebRtcPeerConnection.negotiationNeededCallback.<get-negotiationNeededCallback>|<get-negotiationNeededCallback>(){}[0]
        final fun <set-negotiationNeededCallback>(kotlin/Function0<kotlin/Unit>) // io.ktor.client.webrtc/WebRtcPeerConnection.negotiationNeededCallback.<set-negotiationNeededCallback>|<set-negotiationNeededCallback>(kotlin.Function0<kotlin.Unit>){}[0]

    abstract fun getNativeConnection(): kotlin/Any // io.ktor.client.webrtc/WebRtcPeerConnection.getNativeConnection|getNativeConnection(){}[0]
    abstract fun restartIce() // io.ktor.client.webrtc/WebRtcPeerConnection.restartIce|restartIce(){}[0]
    abstract suspend fun addIceCandidate(io.ktor.client.webrtc/WebRTC.IceCandidate) // io.ktor.client.webrtc/WebRtcPeerConnection.addIceCandidate|addIceCandidate(io.ktor.client.webrtc.WebRTC.IceCandidate){}[0]
    abstract suspend fun addTrack(io.ktor.client.webrtc/WebRTCMedia.Track): io.ktor.client.webrtc/WebRTC.RtpSender // io.ktor.client.webrtc/WebRtcPeerConnection.addTrack|addTrack(io.ktor.client.webrtc.WebRTCMedia.Track){}[0]
    abstract suspend fun createAnswer(): io.ktor.client.webrtc/WebRTC.SessionDescription // io.ktor.client.webrtc/WebRtcPeerConnection.createAnswer|createAnswer(){}[0]
    abstract suspend fun createOffer(): io.ktor.client.webrtc/WebRTC.SessionDescription // io.ktor.client.webrtc/WebRtcPeerConnection.createOffer|createOffer(){}[0]
    abstract suspend fun removeTrack(io.ktor.client.webrtc/WebRTC.RtpSender) // io.ktor.client.webrtc/WebRtcPeerConnection.removeTrack|removeTrack(io.ktor.client.webrtc.WebRTC.RtpSender){}[0]
    abstract suspend fun removeTrack(io.ktor.client.webrtc/WebRTCMedia.Track) // io.ktor.client.webrtc/WebRtcPeerConnection.removeTrack|removeTrack(io.ktor.client.webrtc.WebRTCMedia.Track){}[0]
    abstract suspend fun setLocalDescription(io.ktor.client.webrtc/WebRTC.SessionDescription) // io.ktor.client.webrtc/WebRtcPeerConnection.setLocalDescription|setLocalDescription(io.ktor.client.webrtc.WebRTC.SessionDescription){}[0]
    abstract suspend fun setRemoteDescription(io.ktor.client.webrtc/WebRTC.SessionDescription) // io.ktor.client.webrtc/WebRtcPeerConnection.setRemoteDescription|setRemoteDescription(io.ktor.client.webrtc.WebRTC.SessionDescription){}[0]
    final fun onNegotiationNeeded(kotlin/Function0<kotlin/Unit>) // io.ktor.client.webrtc/WebRtcPeerConnection.onNegotiationNeeded|onNegotiationNeeded(kotlin.Function0<kotlin.Unit>){}[0]
}

final class <#A: kotlin/Any?> io.ktor.client.webrtc/Add : io.ktor.client.webrtc/Operation<#A> { // io.ktor.client.webrtc/Add|null[0]
    constructor <init>(#A) // io.ktor.client.webrtc/Add.<init>|<init>(1:0){}[0]
}

final class <#A: kotlin/Any?> io.ktor.client.webrtc/Remove : io.ktor.client.webrtc/Operation<#A> { // io.ktor.client.webrtc/Remove|null[0]
    constructor <init>(#A) // io.ktor.client.webrtc/Remove.<init>|<init>(1:0){}[0]
}

final class io.ktor.client.webrtc/WebRTCClient : io.ktor.client.webrtc/WebRTCEngine { // io.ktor.client.webrtc/WebRTCClient|null[0]
    constructor <init>(io.ktor.client.webrtc/WebRTCEngine) // io.ktor.client.webrtc/WebRTCClient.<init>|<init>(io.ktor.client.webrtc.WebRTCEngine){}[0]

    final val config // io.ktor.client.webrtc/WebRTCClient.config|{}config[0]
        final fun <get-config>(): io.ktor.client.webrtc/WebRTCConfig // io.ktor.client.webrtc/WebRTCClient.config.<get-config>|<get-config>(){}[0]
    final val coroutineContext // io.ktor.client.webrtc/WebRTCClient.coroutineContext|{}coroutineContext[0]
        final fun <get-coroutineContext>(): kotlin.coroutines/CoroutineContext // io.ktor.client.webrtc/WebRTCClient.coroutineContext.<get-coroutineContext>|<get-coroutineContext>(){}[0]
    final val dispatcher // io.ktor.client.webrtc/WebRTCClient.dispatcher|{}dispatcher[0]
        final fun <get-dispatcher>(): kotlinx.coroutines/CoroutineDispatcher // io.ktor.client.webrtc/WebRTCClient.dispatcher.<get-dispatcher>|<get-dispatcher>(){}[0]
    final val engine // io.ktor.client.webrtc/WebRTCClient.engine|{}engine[0]
        final fun <get-engine>(): io.ktor.client.webrtc/WebRTCEngine // io.ktor.client.webrtc/WebRTCClient.engine.<get-engine>|<get-engine>(){}[0]

    final fun close() // io.ktor.client.webrtc/WebRTCClient.close|close(){}[0]
    final suspend fun createAudioTrack(io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints): io.ktor.client.webrtc/WebRTCMedia.AudioTrack // io.ktor.client.webrtc/WebRTCClient.createAudioTrack|createAudioTrack(io.ktor.client.webrtc.WebRTCMedia.AudioTrackConstraints){}[0]
    final suspend fun createPeerConnection(): io.ktor.client.webrtc/WebRtcPeerConnection // io.ktor.client.webrtc/WebRTCClient.createPeerConnection|createPeerConnection(){}[0]
    final suspend fun createVideoTrack(io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints): io.ktor.client.webrtc/WebRTCMedia.VideoTrack // io.ktor.client.webrtc/WebRTCClient.createVideoTrack|createVideoTrack(io.ktor.client.webrtc.WebRTCMedia.VideoTrackConstraints){}[0]
}

open class io.ktor.client.webrtc/WebRTCConfig { // io.ktor.client.webrtc/WebRTCConfig|null[0]
    constructor <init>() // io.ktor.client.webrtc/WebRTCConfig.<init>|<init>(){}[0]

    final var bundlePolicy // io.ktor.client.webrtc/WebRTCConfig.bundlePolicy|{}bundlePolicy[0]
        final fun <get-bundlePolicy>(): io.ktor.client.webrtc/WebRTC.BundlePolicy // io.ktor.client.webrtc/WebRTCConfig.bundlePolicy.<get-bundlePolicy>|<get-bundlePolicy>(){}[0]
        final fun <set-bundlePolicy>(io.ktor.client.webrtc/WebRTC.BundlePolicy) // io.ktor.client.webrtc/WebRTCConfig.bundlePolicy.<set-bundlePolicy>|<set-bundlePolicy>(io.ktor.client.webrtc.WebRTC.BundlePolicy){}[0]
    final var dispatcher // io.ktor.client.webrtc/WebRTCConfig.dispatcher|{}dispatcher[0]
        final fun <get-dispatcher>(): kotlinx.coroutines/CoroutineDispatcher? // io.ktor.client.webrtc/WebRTCConfig.dispatcher.<get-dispatcher>|<get-dispatcher>(){}[0]
        final fun <set-dispatcher>(kotlinx.coroutines/CoroutineDispatcher?) // io.ktor.client.webrtc/WebRTCConfig.dispatcher.<set-dispatcher>|<set-dispatcher>(kotlinx.coroutines.CoroutineDispatcher?){}[0]
    final var iceCandidatePoolSize // io.ktor.client.webrtc/WebRTCConfig.iceCandidatePoolSize|{}iceCandidatePoolSize[0]
        final fun <get-iceCandidatePoolSize>(): kotlin/Int // io.ktor.client.webrtc/WebRTCConfig.iceCandidatePoolSize.<get-iceCandidatePoolSize>|<get-iceCandidatePoolSize>(){}[0]
        final fun <set-iceCandidatePoolSize>(kotlin/Int) // io.ktor.client.webrtc/WebRTCConfig.iceCandidatePoolSize.<set-iceCandidatePoolSize>|<set-iceCandidatePoolSize>(kotlin.Int){}[0]
    final var iceCandidatesReplay // io.ktor.client.webrtc/WebRTCConfig.iceCandidatesReplay|{}iceCandidatesReplay[0]
        final fun <get-iceCandidatesReplay>(): kotlin/Int // io.ktor.client.webrtc/WebRTCConfig.iceCandidatesReplay.<get-iceCandidatesReplay>|<get-iceCandidatesReplay>(){}[0]
        final fun <set-iceCandidatesReplay>(kotlin/Int) // io.ktor.client.webrtc/WebRTCConfig.iceCandidatesReplay.<set-iceCandidatesReplay>|<set-iceCandidatesReplay>(kotlin.Int){}[0]
    final var iceServers // io.ktor.client.webrtc/WebRTCConfig.iceServers|{}iceServers[0]
        final fun <get-iceServers>(): kotlin.collections/List<io.ktor.client.webrtc/WebRTC.IceServer> // io.ktor.client.webrtc/WebRTCConfig.iceServers.<get-iceServers>|<get-iceServers>(){}[0]
        final fun <set-iceServers>(kotlin.collections/List<io.ktor.client.webrtc/WebRTC.IceServer>) // io.ktor.client.webrtc/WebRTCConfig.iceServers.<set-iceServers>|<set-iceServers>(kotlin.collections.List<io.ktor.client.webrtc.WebRTC.IceServer>){}[0]
    final var iceTransportPolicy // io.ktor.client.webrtc/WebRTCConfig.iceTransportPolicy|{}iceTransportPolicy[0]
        final fun <get-iceTransportPolicy>(): io.ktor.client.webrtc/WebRTC.IceTransportPolicy // io.ktor.client.webrtc/WebRTCConfig.iceTransportPolicy.<get-iceTransportPolicy>|<get-iceTransportPolicy>(){}[0]
        final fun <set-iceTransportPolicy>(io.ktor.client.webrtc/WebRTC.IceTransportPolicy) // io.ktor.client.webrtc/WebRTCConfig.iceTransportPolicy.<set-iceTransportPolicy>|<set-iceTransportPolicy>(io.ktor.client.webrtc.WebRTC.IceTransportPolicy){}[0]
    final var mediaTrackFactory // io.ktor.client.webrtc/WebRTCConfig.mediaTrackFactory|{}mediaTrackFactory[0]
        final fun <get-mediaTrackFactory>(): io.ktor.client.webrtc/MediaTrackFactory? // io.ktor.client.webrtc/WebRTCConfig.mediaTrackFactory.<get-mediaTrackFactory>|<get-mediaTrackFactory>(){}[0]
        final fun <set-mediaTrackFactory>(io.ktor.client.webrtc/MediaTrackFactory?) // io.ktor.client.webrtc/WebRTCConfig.mediaTrackFactory.<set-mediaTrackFactory>|<set-mediaTrackFactory>(io.ktor.client.webrtc.MediaTrackFactory?){}[0]
    final var remoteTracksReplay // io.ktor.client.webrtc/WebRTCConfig.remoteTracksReplay|{}remoteTracksReplay[0]
        final fun <get-remoteTracksReplay>(): kotlin/Int // io.ktor.client.webrtc/WebRTCConfig.remoteTracksReplay.<get-remoteTracksReplay>|<get-remoteTracksReplay>(){}[0]
        final fun <set-remoteTracksReplay>(kotlin/Int) // io.ktor.client.webrtc/WebRTCConfig.remoteTracksReplay.<set-remoteTracksReplay>|<set-remoteTracksReplay>(kotlin.Int){}[0]
    final var rtcpMuxPolicy // io.ktor.client.webrtc/WebRTCConfig.rtcpMuxPolicy|{}rtcpMuxPolicy[0]
        final fun <get-rtcpMuxPolicy>(): io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy // io.ktor.client.webrtc/WebRTCConfig.rtcpMuxPolicy.<get-rtcpMuxPolicy>|<get-rtcpMuxPolicy>(){}[0]
        final fun <set-rtcpMuxPolicy>(io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy) // io.ktor.client.webrtc/WebRTCConfig.rtcpMuxPolicy.<set-rtcpMuxPolicy>|<set-rtcpMuxPolicy>(io.ktor.client.webrtc.WebRTC.RTCPMuxPolicy){}[0]
    final var statsRefreshRate // io.ktor.client.webrtc/WebRTCConfig.statsRefreshRate|{}statsRefreshRate[0]
        final fun <get-statsRefreshRate>(): kotlin/Long // io.ktor.client.webrtc/WebRTCConfig.statsRefreshRate.<get-statsRefreshRate>|<get-statsRefreshRate>(){}[0]
        final fun <set-statsRefreshRate>(kotlin/Long) // io.ktor.client.webrtc/WebRTCConfig.statsRefreshRate.<set-statsRefreshRate>|<set-statsRefreshRate>(kotlin.Long){}[0]
    final var turnServers // io.ktor.client.webrtc/WebRTCConfig.turnServers|{}turnServers[0]
        final fun <get-turnServers>(): kotlin.collections/List<io.ktor.client.webrtc/WebRTC.IceServer> // io.ktor.client.webrtc/WebRTCConfig.turnServers.<get-turnServers>|<get-turnServers>(){}[0]
        final fun <set-turnServers>(kotlin.collections/List<io.ktor.client.webrtc/WebRTC.IceServer>) // io.ktor.client.webrtc/WebRTCConfig.turnServers.<set-turnServers>|<set-turnServers>(kotlin.collections.List<io.ktor.client.webrtc.WebRTC.IceServer>){}[0]
}

sealed class <#A: kotlin/Any?> io.ktor.client.webrtc/Operation { // io.ktor.client.webrtc/Operation|null[0]
    final val item // io.ktor.client.webrtc/Operation.item|{}item[0]
        final fun <get-item>(): #A // io.ktor.client.webrtc/Operation.item.<get-item>|<get-item>(){}[0]
}

final object io.ktor.client.webrtc/WebRTC { // io.ktor.client.webrtc/WebRTC|null[0]
    final enum class BundlePolicy : kotlin/Enum<io.ktor.client.webrtc/WebRTC.BundlePolicy> { // io.ktor.client.webrtc/WebRTC.BundlePolicy|null[0]
        enum entry BALANCED // io.ktor.client.webrtc/WebRTC.BundlePolicy.BALANCED|null[0]
        enum entry MAX_BUNDLE // io.ktor.client.webrtc/WebRTC.BundlePolicy.MAX_BUNDLE|null[0]
        enum entry MAX_COMPAT // io.ktor.client.webrtc/WebRTC.BundlePolicy.MAX_COMPAT|null[0]

        final val entries // io.ktor.client.webrtc/WebRTC.BundlePolicy.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTC.BundlePolicy> // io.ktor.client.webrtc/WebRTC.BundlePolicy.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTC.BundlePolicy // io.ktor.client.webrtc/WebRTC.BundlePolicy.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTC.BundlePolicy> // io.ktor.client.webrtc/WebRTC.BundlePolicy.values|values#static(){}[0]
    }

    final enum class ConnectionState : kotlin/Enum<io.ktor.client.webrtc/WebRTC.ConnectionState> { // io.ktor.client.webrtc/WebRTC.ConnectionState|null[0]
        enum entry CLOSED // io.ktor.client.webrtc/WebRTC.ConnectionState.CLOSED|null[0]
        enum entry CONNECTED // io.ktor.client.webrtc/WebRTC.ConnectionState.CONNECTED|null[0]
        enum entry CONNECTING // io.ktor.client.webrtc/WebRTC.ConnectionState.CONNECTING|null[0]
        enum entry DISCONNECTED // io.ktor.client.webrtc/WebRTC.ConnectionState.DISCONNECTED|null[0]
        enum entry FAILED // io.ktor.client.webrtc/WebRTC.ConnectionState.FAILED|null[0]
        enum entry NEW // io.ktor.client.webrtc/WebRTC.ConnectionState.NEW|null[0]

        final val entries // io.ktor.client.webrtc/WebRTC.ConnectionState.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTC.ConnectionState> // io.ktor.client.webrtc/WebRTC.ConnectionState.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTC.ConnectionState // io.ktor.client.webrtc/WebRTC.ConnectionState.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTC.ConnectionState> // io.ktor.client.webrtc/WebRTC.ConnectionState.values|values#static(){}[0]
    }

    final enum class DegradationPreference : kotlin/Enum<io.ktor.client.webrtc/WebRTC.DegradationPreference> { // io.ktor.client.webrtc/WebRTC.DegradationPreference|null[0]
        enum entry BALANCED // io.ktor.client.webrtc/WebRTC.DegradationPreference.BALANCED|null[0]
        enum entry DISABLED // io.ktor.client.webrtc/WebRTC.DegradationPreference.DISABLED|null[0]
        enum entry MAINTAIN_FRAMERATE // io.ktor.client.webrtc/WebRTC.DegradationPreference.MAINTAIN_FRAMERATE|null[0]
        enum entry MAINTAIN_RESOLUTION // io.ktor.client.webrtc/WebRTC.DegradationPreference.MAINTAIN_RESOLUTION|null[0]

        final val entries // io.ktor.client.webrtc/WebRTC.DegradationPreference.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTC.DegradationPreference> // io.ktor.client.webrtc/WebRTC.DegradationPreference.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTC.DegradationPreference // io.ktor.client.webrtc/WebRTC.DegradationPreference.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTC.DegradationPreference> // io.ktor.client.webrtc/WebRTC.DegradationPreference.values|values#static(){}[0]
    }

    final enum class IceConnectionState : kotlin/Enum<io.ktor.client.webrtc/WebRTC.IceConnectionState> { // io.ktor.client.webrtc/WebRTC.IceConnectionState|null[0]
        enum entry CHECKING // io.ktor.client.webrtc/WebRTC.IceConnectionState.CHECKING|null[0]
        enum entry CLOSED // io.ktor.client.webrtc/WebRTC.IceConnectionState.CLOSED|null[0]
        enum entry COMPLETED // io.ktor.client.webrtc/WebRTC.IceConnectionState.COMPLETED|null[0]
        enum entry CONNECTED // io.ktor.client.webrtc/WebRTC.IceConnectionState.CONNECTED|null[0]
        enum entry DISCONNECTED // io.ktor.client.webrtc/WebRTC.IceConnectionState.DISCONNECTED|null[0]
        enum entry FAILED // io.ktor.client.webrtc/WebRTC.IceConnectionState.FAILED|null[0]
        enum entry NEW // io.ktor.client.webrtc/WebRTC.IceConnectionState.NEW|null[0]

        final val entries // io.ktor.client.webrtc/WebRTC.IceConnectionState.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTC.IceConnectionState> // io.ktor.client.webrtc/WebRTC.IceConnectionState.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun isSuccessful(): kotlin/Boolean // io.ktor.client.webrtc/WebRTC.IceConnectionState.isSuccessful|isSuccessful(){}[0]
        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTC.IceConnectionState // io.ktor.client.webrtc/WebRTC.IceConnectionState.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTC.IceConnectionState> // io.ktor.client.webrtc/WebRTC.IceConnectionState.values|values#static(){}[0]
    }

    final enum class IceGatheringState : kotlin/Enum<io.ktor.client.webrtc/WebRTC.IceGatheringState> { // io.ktor.client.webrtc/WebRTC.IceGatheringState|null[0]
        enum entry COMPLETE // io.ktor.client.webrtc/WebRTC.IceGatheringState.COMPLETE|null[0]
        enum entry GATHERING // io.ktor.client.webrtc/WebRTC.IceGatheringState.GATHERING|null[0]
        enum entry NEW // io.ktor.client.webrtc/WebRTC.IceGatheringState.NEW|null[0]

        final val entries // io.ktor.client.webrtc/WebRTC.IceGatheringState.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTC.IceGatheringState> // io.ktor.client.webrtc/WebRTC.IceGatheringState.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTC.IceGatheringState // io.ktor.client.webrtc/WebRTC.IceGatheringState.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTC.IceGatheringState> // io.ktor.client.webrtc/WebRTC.IceGatheringState.values|values#static(){}[0]
    }

    final enum class IceTransportPolicy : kotlin/Enum<io.ktor.client.webrtc/WebRTC.IceTransportPolicy> { // io.ktor.client.webrtc/WebRTC.IceTransportPolicy|null[0]
        enum entry ALL // io.ktor.client.webrtc/WebRTC.IceTransportPolicy.ALL|null[0]
        enum entry RELAY // io.ktor.client.webrtc/WebRTC.IceTransportPolicy.RELAY|null[0]

        final val entries // io.ktor.client.webrtc/WebRTC.IceTransportPolicy.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTC.IceTransportPolicy> // io.ktor.client.webrtc/WebRTC.IceTransportPolicy.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTC.IceTransportPolicy // io.ktor.client.webrtc/WebRTC.IceTransportPolicy.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTC.IceTransportPolicy> // io.ktor.client.webrtc/WebRTC.IceTransportPolicy.values|values#static(){}[0]
    }

    final enum class RTCPMuxPolicy : kotlin/Enum<io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy> { // io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy|null[0]
        enum entry NEGOTIATE // io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy.NEGOTIATE|null[0]
        enum entry REQUIRE // io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy.REQUIRE|null[0]

        final val entries // io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy> // io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy // io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy> // io.ktor.client.webrtc/WebRTC.RTCPMuxPolicy.values|values#static(){}[0]
    }

    final enum class SessionDescriptionType : kotlin/Enum<io.ktor.client.webrtc/WebRTC.SessionDescriptionType> { // io.ktor.client.webrtc/WebRTC.SessionDescriptionType|null[0]
        enum entry ANSWER // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.ANSWER|null[0]
        enum entry OFFER // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.OFFER|null[0]
        enum entry PROVISIONAL_ANSWER // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.PROVISIONAL_ANSWER|null[0]
        enum entry ROLLBACK // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.ROLLBACK|null[0]

        final val entries // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTC.SessionDescriptionType> // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTC.SessionDescriptionType // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTC.SessionDescriptionType> // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.values|values#static(){}[0]

        final object Companion : kotlinx.serialization.internal/SerializerFactory { // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.Companion|null[0]
            final fun serializer(): kotlinx.serialization/KSerializer<io.ktor.client.webrtc/WebRTC.SessionDescriptionType> // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.Companion.serializer|serializer(){}[0]
            final fun serializer(kotlin/Array<out kotlinx.serialization/KSerializer<*>>...): kotlinx.serialization/KSerializer<*> // io.ktor.client.webrtc/WebRTC.SessionDescriptionType.Companion.serializer|serializer(kotlin.Array<out|kotlinx.serialization.KSerializer<*>>...){}[0]
        }
    }

    final enum class SignalingState : kotlin/Enum<io.ktor.client.webrtc/WebRTC.SignalingState> { // io.ktor.client.webrtc/WebRTC.SignalingState|null[0]
        enum entry CLOSED // io.ktor.client.webrtc/WebRTC.SignalingState.CLOSED|null[0]
        enum entry HAVE_LOCAL_OFFER // io.ktor.client.webrtc/WebRTC.SignalingState.HAVE_LOCAL_OFFER|null[0]
        enum entry HAVE_LOCAL_PROVISIONAL_ANSWER // io.ktor.client.webrtc/WebRTC.SignalingState.HAVE_LOCAL_PROVISIONAL_ANSWER|null[0]
        enum entry HAVE_REMOTE_OFFER // io.ktor.client.webrtc/WebRTC.SignalingState.HAVE_REMOTE_OFFER|null[0]
        enum entry HAVE_REMOTE_PROVISIONAL_ANSWER // io.ktor.client.webrtc/WebRTC.SignalingState.HAVE_REMOTE_PROVISIONAL_ANSWER|null[0]
        enum entry STABLE // io.ktor.client.webrtc/WebRTC.SignalingState.STABLE|null[0]

        final val entries // io.ktor.client.webrtc/WebRTC.SignalingState.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTC.SignalingState> // io.ktor.client.webrtc/WebRTC.SignalingState.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTC.SignalingState // io.ktor.client.webrtc/WebRTC.SignalingState.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTC.SignalingState> // io.ktor.client.webrtc/WebRTC.SignalingState.values|values#static(){}[0]
    }

    abstract interface DtmfSender { // io.ktor.client.webrtc/WebRTC.DtmfSender|null[0]
        abstract val canInsertDTMF // io.ktor.client.webrtc/WebRTC.DtmfSender.canInsertDTMF|{}canInsertDTMF[0]
            abstract fun <get-canInsertDTMF>(): kotlin/Boolean // io.ktor.client.webrtc/WebRTC.DtmfSender.canInsertDTMF.<get-canInsertDTMF>|<get-canInsertDTMF>(){}[0]
        abstract val toneBuffer // io.ktor.client.webrtc/WebRTC.DtmfSender.toneBuffer|{}toneBuffer[0]
            abstract fun <get-toneBuffer>(): kotlin/String // io.ktor.client.webrtc/WebRTC.DtmfSender.toneBuffer.<get-toneBuffer>|<get-toneBuffer>(){}[0]

        abstract fun getNative(): kotlin/Any // io.ktor.client.webrtc/WebRTC.DtmfSender.getNative|getNative(){}[0]
        abstract fun insertDTMF(kotlin/String, kotlin/Int, kotlin/Int) // io.ktor.client.webrtc/WebRTC.DtmfSender.insertDTMF|insertDTMF(kotlin.String;kotlin.Int;kotlin.Int){}[0]
    }

    abstract interface RtpParameters { // io.ktor.client.webrtc/WebRTC.RtpParameters|null[0]
        abstract val codecs // io.ktor.client.webrtc/WebRTC.RtpParameters.codecs|{}codecs[0]
            abstract fun <get-codecs>(): kotlin.collections/Iterable<kotlin/Any> // io.ktor.client.webrtc/WebRTC.RtpParameters.codecs.<get-codecs>|<get-codecs>(){}[0]
        abstract val degradationPreference // io.ktor.client.webrtc/WebRTC.RtpParameters.degradationPreference|{}degradationPreference[0]
            abstract fun <get-degradationPreference>(): io.ktor.client.webrtc/WebRTC.DegradationPreference // io.ktor.client.webrtc/WebRTC.RtpParameters.degradationPreference.<get-degradationPreference>|<get-degradationPreference>(){}[0]
        abstract val encodings // io.ktor.client.webrtc/WebRTC.RtpParameters.encodings|{}encodings[0]
            abstract fun <get-encodings>(): kotlin.collections/Iterable<kotlin/Any> // io.ktor.client.webrtc/WebRTC.RtpParameters.encodings.<get-encodings>|<get-encodings>(){}[0]
        abstract val headerExtensions // io.ktor.client.webrtc/WebRTC.RtpParameters.headerExtensions|{}headerExtensions[0]
            abstract fun <get-headerExtensions>(): kotlin.collections/Iterable<io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters> // io.ktor.client.webrtc/WebRTC.RtpParameters.headerExtensions.<get-headerExtensions>|<get-headerExtensions>(){}[0]
        abstract val rtcp // io.ktor.client.webrtc/WebRTC.RtpParameters.rtcp|{}rtcp[0]
            abstract fun <get-rtcp>(): kotlin/Any // io.ktor.client.webrtc/WebRTC.RtpParameters.rtcp.<get-rtcp>|<get-rtcp>(){}[0]
        abstract val transactionId // io.ktor.client.webrtc/WebRTC.RtpParameters.transactionId|{}transactionId[0]
            abstract fun <get-transactionId>(): kotlin/String // io.ktor.client.webrtc/WebRTC.RtpParameters.transactionId.<get-transactionId>|<get-transactionId>(){}[0]
    }

    abstract interface RtpSender { // io.ktor.client.webrtc/WebRTC.RtpSender|null[0]
        abstract val dtmf // io.ktor.client.webrtc/WebRTC.RtpSender.dtmf|{}dtmf[0]
            abstract fun <get-dtmf>(): io.ktor.client.webrtc/WebRTC.DtmfSender? // io.ktor.client.webrtc/WebRTC.RtpSender.dtmf.<get-dtmf>|<get-dtmf>(){}[0]
        abstract val track // io.ktor.client.webrtc/WebRTC.RtpSender.track|{}track[0]
            abstract fun <get-track>(): io.ktor.client.webrtc/WebRTCMedia.Track? // io.ktor.client.webrtc/WebRTC.RtpSender.track.<get-track>|<get-track>(){}[0]

        abstract fun getNative(): kotlin/Any // io.ktor.client.webrtc/WebRTC.RtpSender.getNative|getNative(){}[0]
        abstract suspend fun getParameters(): io.ktor.client.webrtc/WebRTC.RtpParameters // io.ktor.client.webrtc/WebRTC.RtpSender.getParameters|getParameters(){}[0]
        abstract suspend fun replaceTrack(io.ktor.client.webrtc/WebRTCMedia.Track?) // io.ktor.client.webrtc/WebRTC.RtpSender.replaceTrack|replaceTrack(io.ktor.client.webrtc.WebRTCMedia.Track?){}[0]
        abstract suspend fun setParameters(io.ktor.client.webrtc/WebRTC.RtpParameters) // io.ktor.client.webrtc/WebRTC.RtpSender.setParameters|setParameters(io.ktor.client.webrtc.WebRTC.RtpParameters){}[0]
    }

    final class IceCandidate { // io.ktor.client.webrtc/WebRTC.IceCandidate|null[0]
        constructor <init>(kotlin/String, kotlin/String, kotlin/Int) // io.ktor.client.webrtc/WebRTC.IceCandidate.<init>|<init>(kotlin.String;kotlin.String;kotlin.Int){}[0]

        final val candidate // io.ktor.client.webrtc/WebRTC.IceCandidate.candidate|{}candidate[0]
            final fun <get-candidate>(): kotlin/String // io.ktor.client.webrtc/WebRTC.IceCandidate.candidate.<get-candidate>|<get-candidate>(){}[0]
        final val sdpMLineIndex // io.ktor.client.webrtc/WebRTC.IceCandidate.sdpMLineIndex|{}sdpMLineIndex[0]
            final fun <get-sdpMLineIndex>(): kotlin/Int // io.ktor.client.webrtc/WebRTC.IceCandidate.sdpMLineIndex.<get-sdpMLineIndex>|<get-sdpMLineIndex>(){}[0]
        final val sdpMid // io.ktor.client.webrtc/WebRTC.IceCandidate.sdpMid|{}sdpMid[0]
            final fun <get-sdpMid>(): kotlin/String // io.ktor.client.webrtc/WebRTC.IceCandidate.sdpMid.<get-sdpMid>|<get-sdpMid>(){}[0]

        final fun component1(): kotlin/String // io.ktor.client.webrtc/WebRTC.IceCandidate.component1|component1(){}[0]
        final fun component2(): kotlin/String // io.ktor.client.webrtc/WebRTC.IceCandidate.component2|component2(){}[0]
        final fun component3(): kotlin/Int // io.ktor.client.webrtc/WebRTC.IceCandidate.component3|component3(){}[0]
        final fun copy(kotlin/String = ..., kotlin/String = ..., kotlin/Int = ...): io.ktor.client.webrtc/WebRTC.IceCandidate // io.ktor.client.webrtc/WebRTC.IceCandidate.copy|copy(kotlin.String;kotlin.String;kotlin.Int){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.client.webrtc/WebRTC.IceCandidate.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.client.webrtc/WebRTC.IceCandidate.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.client.webrtc/WebRTC.IceCandidate.toString|toString(){}[0]

        final object $serializer : kotlinx.serialization.internal/GeneratedSerializer<io.ktor.client.webrtc/WebRTC.IceCandidate> { // io.ktor.client.webrtc/WebRTC.IceCandidate.$serializer|null[0]
            final val descriptor // io.ktor.client.webrtc/WebRTC.IceCandidate.$serializer.descriptor|{}descriptor[0]
                final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // io.ktor.client.webrtc/WebRTC.IceCandidate.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]

            final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // io.ktor.client.webrtc/WebRTC.IceCandidate.$serializer.childSerializers|childSerializers(){}[0]
            final fun deserialize(kotlinx.serialization.encoding/Decoder): io.ktor.client.webrtc/WebRTC.IceCandidate // io.ktor.client.webrtc/WebRTC.IceCandidate.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
            final fun serialize(kotlinx.serialization.encoding/Encoder, io.ktor.client.webrtc/WebRTC.IceCandidate) // io.ktor.client.webrtc/WebRTC.IceCandidate.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;io.ktor.client.webrtc.WebRTC.IceCandidate){}[0]
        }

        final object Companion { // io.ktor.client.webrtc/WebRTC.IceCandidate.Companion|null[0]
            final fun serializer(): kotlinx.serialization/KSerializer<io.ktor.client.webrtc/WebRTC.IceCandidate> // io.ktor.client.webrtc/WebRTC.IceCandidate.Companion.serializer|serializer(){}[0]
        }
    }

    final class IceException : kotlin/RuntimeException { // io.ktor.client.webrtc/WebRTC.IceException|null[0]
        constructor <init>(kotlin/String?, kotlin/Throwable? = ...) // io.ktor.client.webrtc/WebRTC.IceException.<init>|<init>(kotlin.String?;kotlin.Throwable?){}[0]
    }

    final class IceServer { // io.ktor.client.webrtc/WebRTC.IceServer|null[0]
        constructor <init>(kotlin/String, kotlin/String? = ..., kotlin/String? = ...) // io.ktor.client.webrtc/WebRTC.IceServer.<init>|<init>(kotlin.String;kotlin.String?;kotlin.String?){}[0]

        final val credential // io.ktor.client.webrtc/WebRTC.IceServer.credential|{}credential[0]
            final fun <get-credential>(): kotlin/String? // io.ktor.client.webrtc/WebRTC.IceServer.credential.<get-credential>|<get-credential>(){}[0]
        final val urls // io.ktor.client.webrtc/WebRTC.IceServer.urls|{}urls[0]
            final fun <get-urls>(): kotlin/String // io.ktor.client.webrtc/WebRTC.IceServer.urls.<get-urls>|<get-urls>(){}[0]
        final val username // io.ktor.client.webrtc/WebRTC.IceServer.username|{}username[0]
            final fun <get-username>(): kotlin/String? // io.ktor.client.webrtc/WebRTC.IceServer.username.<get-username>|<get-username>(){}[0]

        final fun component1(): kotlin/String // io.ktor.client.webrtc/WebRTC.IceServer.component1|component1(){}[0]
        final fun component2(): kotlin/String? // io.ktor.client.webrtc/WebRTC.IceServer.component2|component2(){}[0]
        final fun component3(): kotlin/String? // io.ktor.client.webrtc/WebRTC.IceServer.component3|component3(){}[0]
        final fun copy(kotlin/String = ..., kotlin/String? = ..., kotlin/String? = ...): io.ktor.client.webrtc/WebRTC.IceServer // io.ktor.client.webrtc/WebRTC.IceServer.copy|copy(kotlin.String;kotlin.String?;kotlin.String?){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.client.webrtc/WebRTC.IceServer.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.client.webrtc/WebRTC.IceServer.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.client.webrtc/WebRTC.IceServer.toString|toString(){}[0]
    }

    final class RtpHeaderExtensionParameters { // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters|null[0]
        constructor <init>(kotlin/Int, kotlin/String, kotlin/Boolean) // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.<init>|<init>(kotlin.Int;kotlin.String;kotlin.Boolean){}[0]

        final val encrypted // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.encrypted|{}encrypted[0]
            final fun <get-encrypted>(): kotlin/Boolean // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.encrypted.<get-encrypted>|<get-encrypted>(){}[0]
        final val id // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.id|{}id[0]
            final fun <get-id>(): kotlin/Int // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.id.<get-id>|<get-id>(){}[0]
        final val uri // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.uri|{}uri[0]
            final fun <get-uri>(): kotlin/String // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.uri.<get-uri>|<get-uri>(){}[0]

        final fun component1(): kotlin/Int // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.component1|component1(){}[0]
        final fun component2(): kotlin/String // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.component2|component2(){}[0]
        final fun component3(): kotlin/Boolean // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.component3|component3(){}[0]
        final fun copy(kotlin/Int = ..., kotlin/String = ..., kotlin/Boolean = ...): io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.copy|copy(kotlin.Int;kotlin.String;kotlin.Boolean){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.client.webrtc/WebRTC.RtpHeaderExtensionParameters.toString|toString(){}[0]
    }

    final class SdpException : kotlin/RuntimeException { // io.ktor.client.webrtc/WebRTC.SdpException|null[0]
        constructor <init>(kotlin/String?, kotlin/Throwable? = ...) // io.ktor.client.webrtc/WebRTC.SdpException.<init>|<init>(kotlin.String?;kotlin.Throwable?){}[0]
    }

    final class SessionDescription { // io.ktor.client.webrtc/WebRTC.SessionDescription|null[0]
        constructor <init>(io.ktor.client.webrtc/WebRTC.SessionDescriptionType, kotlin/String) // io.ktor.client.webrtc/WebRTC.SessionDescription.<init>|<init>(io.ktor.client.webrtc.WebRTC.SessionDescriptionType;kotlin.String){}[0]

        final val sdp // io.ktor.client.webrtc/WebRTC.SessionDescription.sdp|{}sdp[0]
            final fun <get-sdp>(): kotlin/String // io.ktor.client.webrtc/WebRTC.SessionDescription.sdp.<get-sdp>|<get-sdp>(){}[0]
        final val type // io.ktor.client.webrtc/WebRTC.SessionDescription.type|{}type[0]
            final fun <get-type>(): io.ktor.client.webrtc/WebRTC.SessionDescriptionType // io.ktor.client.webrtc/WebRTC.SessionDescription.type.<get-type>|<get-type>(){}[0]

        final fun component1(): io.ktor.client.webrtc/WebRTC.SessionDescriptionType // io.ktor.client.webrtc/WebRTC.SessionDescription.component1|component1(){}[0]
        final fun component2(): kotlin/String // io.ktor.client.webrtc/WebRTC.SessionDescription.component2|component2(){}[0]
        final fun copy(io.ktor.client.webrtc/WebRTC.SessionDescriptionType = ..., kotlin/String = ...): io.ktor.client.webrtc/WebRTC.SessionDescription // io.ktor.client.webrtc/WebRTC.SessionDescription.copy|copy(io.ktor.client.webrtc.WebRTC.SessionDescriptionType;kotlin.String){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.client.webrtc/WebRTC.SessionDescription.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.client.webrtc/WebRTC.SessionDescription.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.client.webrtc/WebRTC.SessionDescription.toString|toString(){}[0]

        final object $serializer : kotlinx.serialization.internal/GeneratedSerializer<io.ktor.client.webrtc/WebRTC.SessionDescription> { // io.ktor.client.webrtc/WebRTC.SessionDescription.$serializer|null[0]
            final val descriptor // io.ktor.client.webrtc/WebRTC.SessionDescription.$serializer.descriptor|{}descriptor[0]
                final fun <get-descriptor>(): kotlinx.serialization.descriptors/SerialDescriptor // io.ktor.client.webrtc/WebRTC.SessionDescription.$serializer.descriptor.<get-descriptor>|<get-descriptor>(){}[0]

            final fun childSerializers(): kotlin/Array<kotlinx.serialization/KSerializer<*>> // io.ktor.client.webrtc/WebRTC.SessionDescription.$serializer.childSerializers|childSerializers(){}[0]
            final fun deserialize(kotlinx.serialization.encoding/Decoder): io.ktor.client.webrtc/WebRTC.SessionDescription // io.ktor.client.webrtc/WebRTC.SessionDescription.$serializer.deserialize|deserialize(kotlinx.serialization.encoding.Decoder){}[0]
            final fun serialize(kotlinx.serialization.encoding/Encoder, io.ktor.client.webrtc/WebRTC.SessionDescription) // io.ktor.client.webrtc/WebRTC.SessionDescription.$serializer.serialize|serialize(kotlinx.serialization.encoding.Encoder;io.ktor.client.webrtc.WebRTC.SessionDescription){}[0]
        }

        final object Companion { // io.ktor.client.webrtc/WebRTC.SessionDescription.Companion|null[0]
            final val $childSerializers // io.ktor.client.webrtc/WebRTC.SessionDescription.Companion.$childSerializers|{}$childSerializers[0]

            final fun serializer(): kotlinx.serialization/KSerializer<io.ktor.client.webrtc/WebRTC.SessionDescription> // io.ktor.client.webrtc/WebRTC.SessionDescription.Companion.serializer|serializer(){}[0]
        }
    }

    final class Stats { // io.ktor.client.webrtc/WebRTC.Stats|null[0]
        constructor <init>(kotlin/String, kotlin/String, kotlin/Long, kotlin.collections/Map<kotlin/String, kotlin/Any?>) // io.ktor.client.webrtc/WebRTC.Stats.<init>|<init>(kotlin.String;kotlin.String;kotlin.Long;kotlin.collections.Map<kotlin.String,kotlin.Any?>){}[0]

        final val id // io.ktor.client.webrtc/WebRTC.Stats.id|{}id[0]
            final fun <get-id>(): kotlin/String // io.ktor.client.webrtc/WebRTC.Stats.id.<get-id>|<get-id>(){}[0]
        final val props // io.ktor.client.webrtc/WebRTC.Stats.props|{}props[0]
            final fun <get-props>(): kotlin.collections/Map<kotlin/String, kotlin/Any?> // io.ktor.client.webrtc/WebRTC.Stats.props.<get-props>|<get-props>(){}[0]
        final val timestamp // io.ktor.client.webrtc/WebRTC.Stats.timestamp|{}timestamp[0]
            final fun <get-timestamp>(): kotlin/Long // io.ktor.client.webrtc/WebRTC.Stats.timestamp.<get-timestamp>|<get-timestamp>(){}[0]
        final val type // io.ktor.client.webrtc/WebRTC.Stats.type|{}type[0]
            final fun <get-type>(): kotlin/String // io.ktor.client.webrtc/WebRTC.Stats.type.<get-type>|<get-type>(){}[0]

        final fun component1(): kotlin/String // io.ktor.client.webrtc/WebRTC.Stats.component1|component1(){}[0]
        final fun component2(): kotlin/String // io.ktor.client.webrtc/WebRTC.Stats.component2|component2(){}[0]
        final fun component3(): kotlin/Long // io.ktor.client.webrtc/WebRTC.Stats.component3|component3(){}[0]
        final fun component4(): kotlin.collections/Map<kotlin/String, kotlin/Any?> // io.ktor.client.webrtc/WebRTC.Stats.component4|component4(){}[0]
        final fun copy(kotlin/String = ..., kotlin/String = ..., kotlin/Long = ..., kotlin.collections/Map<kotlin/String, kotlin/Any?> = ...): io.ktor.client.webrtc/WebRTC.Stats // io.ktor.client.webrtc/WebRTC.Stats.copy|copy(kotlin.String;kotlin.String;kotlin.Long;kotlin.collections.Map<kotlin.String,kotlin.Any?>){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.client.webrtc/WebRTC.Stats.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.client.webrtc/WebRTC.Stats.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.client.webrtc/WebRTC.Stats.toString|toString(){}[0]
    }
}

final object io.ktor.client.webrtc/WebRTCMedia { // io.ktor.client.webrtc/WebRTCMedia|null[0]
    final enum class FacingMode : kotlin/Enum<io.ktor.client.webrtc/WebRTCMedia.FacingMode> { // io.ktor.client.webrtc/WebRTCMedia.FacingMode|null[0]
        enum entry ENVIRONMENT // io.ktor.client.webrtc/WebRTCMedia.FacingMode.ENVIRONMENT|null[0]
        enum entry LEFT // io.ktor.client.webrtc/WebRTCMedia.FacingMode.LEFT|null[0]
        enum entry RIGHT // io.ktor.client.webrtc/WebRTCMedia.FacingMode.RIGHT|null[0]
        enum entry USER // io.ktor.client.webrtc/WebRTCMedia.FacingMode.USER|null[0]

        final val entries // io.ktor.client.webrtc/WebRTCMedia.FacingMode.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTCMedia.FacingMode> // io.ktor.client.webrtc/WebRTCMedia.FacingMode.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTCMedia.FacingMode // io.ktor.client.webrtc/WebRTCMedia.FacingMode.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTCMedia.FacingMode> // io.ktor.client.webrtc/WebRTCMedia.FacingMode.values|values#static(){}[0]
    }

    final enum class ResizeMode : kotlin/Enum<io.ktor.client.webrtc/WebRTCMedia.ResizeMode> { // io.ktor.client.webrtc/WebRTCMedia.ResizeMode|null[0]
        enum entry CROP_AND_SCALE // io.ktor.client.webrtc/WebRTCMedia.ResizeMode.CROP_AND_SCALE|null[0]
        enum entry NONE // io.ktor.client.webrtc/WebRTCMedia.ResizeMode.NONE|null[0]

        final val entries // io.ktor.client.webrtc/WebRTCMedia.ResizeMode.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTCMedia.ResizeMode> // io.ktor.client.webrtc/WebRTCMedia.ResizeMode.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTCMedia.ResizeMode // io.ktor.client.webrtc/WebRTCMedia.ResizeMode.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTCMedia.ResizeMode> // io.ktor.client.webrtc/WebRTCMedia.ResizeMode.values|values#static(){}[0]
    }

    final enum class TrackType : kotlin/Enum<io.ktor.client.webrtc/WebRTCMedia.TrackType> { // io.ktor.client.webrtc/WebRTCMedia.TrackType|null[0]
        enum entry AUDIO // io.ktor.client.webrtc/WebRTCMedia.TrackType.AUDIO|null[0]
        enum entry VIDEO // io.ktor.client.webrtc/WebRTCMedia.TrackType.VIDEO|null[0]

        final val entries // io.ktor.client.webrtc/WebRTCMedia.TrackType.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<io.ktor.client.webrtc/WebRTCMedia.TrackType> // io.ktor.client.webrtc/WebRTCMedia.TrackType.entries.<get-entries>|<get-entries>#static(){}[0]

        final fun valueOf(kotlin/String): io.ktor.client.webrtc/WebRTCMedia.TrackType // io.ktor.client.webrtc/WebRTCMedia.TrackType.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<io.ktor.client.webrtc/WebRTCMedia.TrackType> // io.ktor.client.webrtc/WebRTCMedia.TrackType.values|values#static(){}[0]
    }

    abstract interface AudioTrack : io.ktor.client.webrtc/WebRTCMedia.Track // io.ktor.client.webrtc/WebRTCMedia.AudioTrack|null[0]

    abstract interface Track : kotlin/AutoCloseable { // io.ktor.client.webrtc/WebRTCMedia.Track|null[0]
        abstract val enabled // io.ktor.client.webrtc/WebRTCMedia.Track.enabled|{}enabled[0]
            abstract fun <get-enabled>(): kotlin/Boolean // io.ktor.client.webrtc/WebRTCMedia.Track.enabled.<get-enabled>|<get-enabled>(){}[0]
        abstract val id // io.ktor.client.webrtc/WebRTCMedia.Track.id|{}id[0]
            abstract fun <get-id>(): kotlin/String // io.ktor.client.webrtc/WebRTCMedia.Track.id.<get-id>|<get-id>(){}[0]
        abstract val kind // io.ktor.client.webrtc/WebRTCMedia.Track.kind|{}kind[0]
            abstract fun <get-kind>(): io.ktor.client.webrtc/WebRTCMedia.TrackType // io.ktor.client.webrtc/WebRTCMedia.Track.kind.<get-kind>|<get-kind>(){}[0]

        abstract fun enable(kotlin/Boolean) // io.ktor.client.webrtc/WebRTCMedia.Track.enable|enable(kotlin.Boolean){}[0]
        abstract fun getNative(): kotlin/Any // io.ktor.client.webrtc/WebRTCMedia.Track.getNative|getNative(){}[0]
    }

    abstract interface VideoTrack : io.ktor.client.webrtc/WebRTCMedia.Track // io.ktor.client.webrtc/WebRTCMedia.VideoTrack|null[0]

    final class AudioTrackConstraints { // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints|null[0]
        constructor <init>(kotlin/Double? = ..., kotlin/Int? = ..., kotlin/Int? = ..., kotlin/Boolean? = ..., kotlin/Boolean? = ..., kotlin/Boolean? = ..., kotlin/Double? = ..., kotlin/Int? = ...) // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.<init>|<init>(kotlin.Double?;kotlin.Int?;kotlin.Int?;kotlin.Boolean?;kotlin.Boolean?;kotlin.Boolean?;kotlin.Double?;kotlin.Int?){}[0]

        final var autoGainControl // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.autoGainControl|{}autoGainControl[0]
            final fun <get-autoGainControl>(): kotlin/Boolean? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.autoGainControl.<get-autoGainControl>|<get-autoGainControl>(){}[0]
            final fun <set-autoGainControl>(kotlin/Boolean?) // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.autoGainControl.<set-autoGainControl>|<set-autoGainControl>(kotlin.Boolean?){}[0]
        final var channelCount // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.channelCount|{}channelCount[0]
            final fun <get-channelCount>(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.channelCount.<get-channelCount>|<get-channelCount>(){}[0]
            final fun <set-channelCount>(kotlin/Int?) // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.channelCount.<set-channelCount>|<set-channelCount>(kotlin.Int?){}[0]
        final var echoCancellation // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.echoCancellation|{}echoCancellation[0]
            final fun <get-echoCancellation>(): kotlin/Boolean? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.echoCancellation.<get-echoCancellation>|<get-echoCancellation>(){}[0]
            final fun <set-echoCancellation>(kotlin/Boolean?) // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.echoCancellation.<set-echoCancellation>|<set-echoCancellation>(kotlin.Boolean?){}[0]
        final var latency // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.latency|{}latency[0]
            final fun <get-latency>(): kotlin/Double? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.latency.<get-latency>|<get-latency>(){}[0]
            final fun <set-latency>(kotlin/Double?) // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.latency.<set-latency>|<set-latency>(kotlin.Double?){}[0]
        final var noiseSuppression // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.noiseSuppression|{}noiseSuppression[0]
            final fun <get-noiseSuppression>(): kotlin/Boolean? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.noiseSuppression.<get-noiseSuppression>|<get-noiseSuppression>(){}[0]
            final fun <set-noiseSuppression>(kotlin/Boolean?) // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.noiseSuppression.<set-noiseSuppression>|<set-noiseSuppression>(kotlin.Boolean?){}[0]
        final var sampleRate // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.sampleRate|{}sampleRate[0]
            final fun <get-sampleRate>(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.sampleRate.<get-sampleRate>|<get-sampleRate>(){}[0]
            final fun <set-sampleRate>(kotlin/Int?) // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.sampleRate.<set-sampleRate>|<set-sampleRate>(kotlin.Int?){}[0]
        final var sampleSize // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.sampleSize|{}sampleSize[0]
            final fun <get-sampleSize>(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.sampleSize.<get-sampleSize>|<get-sampleSize>(){}[0]
            final fun <set-sampleSize>(kotlin/Int?) // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.sampleSize.<set-sampleSize>|<set-sampleSize>(kotlin.Int?){}[0]
        final var volume // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.volume|{}volume[0]
            final fun <get-volume>(): kotlin/Double? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.volume.<get-volume>|<get-volume>(){}[0]
            final fun <set-volume>(kotlin/Double?) // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.volume.<set-volume>|<set-volume>(kotlin.Double?){}[0]

        final fun component1(): kotlin/Double? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.component1|component1(){}[0]
        final fun component2(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.component2|component2(){}[0]
        final fun component3(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.component3|component3(){}[0]
        final fun component4(): kotlin/Boolean? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.component4|component4(){}[0]
        final fun component5(): kotlin/Boolean? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.component5|component5(){}[0]
        final fun component6(): kotlin/Boolean? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.component6|component6(){}[0]
        final fun component7(): kotlin/Double? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.component7|component7(){}[0]
        final fun component8(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.component8|component8(){}[0]
        final fun copy(kotlin/Double? = ..., kotlin/Int? = ..., kotlin/Int? = ..., kotlin/Boolean? = ..., kotlin/Boolean? = ..., kotlin/Boolean? = ..., kotlin/Double? = ..., kotlin/Int? = ...): io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.copy|copy(kotlin.Double?;kotlin.Int?;kotlin.Int?;kotlin.Boolean?;kotlin.Boolean?;kotlin.Boolean?;kotlin.Double?;kotlin.Int?){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.client.webrtc/WebRTCMedia.AudioTrackConstraints.toString|toString(){}[0]
    }

    final class DeviceException : kotlin/RuntimeException { // io.ktor.client.webrtc/WebRTCMedia.DeviceException|null[0]
        constructor <init>(kotlin/String?, kotlin/Throwable? = ...) // io.ktor.client.webrtc/WebRTCMedia.DeviceException.<init>|<init>(kotlin.String?;kotlin.Throwable?){}[0]
    }

    final class PermissionException : kotlin/RuntimeException { // io.ktor.client.webrtc/WebRTCMedia.PermissionException|null[0]
        constructor <init>(kotlin/String?) // io.ktor.client.webrtc/WebRTCMedia.PermissionException.<init>|<init>(kotlin.String?){}[0]
    }

    final class VideoTrackConstraints { // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints|null[0]
        constructor <init>(kotlin/Int? = ..., kotlin/Int? = ..., kotlin/Int? = ..., kotlin/Double? = ..., io.ktor.client.webrtc/WebRTCMedia.FacingMode? = ..., io.ktor.client.webrtc/WebRTCMedia.ResizeMode? = ...) // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.<init>|<init>(kotlin.Int?;kotlin.Int?;kotlin.Int?;kotlin.Double?;io.ktor.client.webrtc.WebRTCMedia.FacingMode?;io.ktor.client.webrtc.WebRTCMedia.ResizeMode?){}[0]

        final val aspectRatio // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.aspectRatio|{}aspectRatio[0]
            final fun <get-aspectRatio>(): kotlin/Double? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.aspectRatio.<get-aspectRatio>|<get-aspectRatio>(){}[0]
        final val facingMode // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.facingMode|{}facingMode[0]
            final fun <get-facingMode>(): io.ktor.client.webrtc/WebRTCMedia.FacingMode? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.facingMode.<get-facingMode>|<get-facingMode>(){}[0]
        final val frameRate // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.frameRate|{}frameRate[0]
            final fun <get-frameRate>(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.frameRate.<get-frameRate>|<get-frameRate>(){}[0]
        final val height // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.height|{}height[0]
            final fun <get-height>(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.height.<get-height>|<get-height>(){}[0]
        final val resizeMode // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.resizeMode|{}resizeMode[0]
            final fun <get-resizeMode>(): io.ktor.client.webrtc/WebRTCMedia.ResizeMode? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.resizeMode.<get-resizeMode>|<get-resizeMode>(){}[0]
        final val width // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.width|{}width[0]
            final fun <get-width>(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.width.<get-width>|<get-width>(){}[0]

        final fun component1(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.component1|component1(){}[0]
        final fun component2(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.component2|component2(){}[0]
        final fun component3(): kotlin/Int? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.component3|component3(){}[0]
        final fun component4(): kotlin/Double? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.component4|component4(){}[0]
        final fun component5(): io.ktor.client.webrtc/WebRTCMedia.FacingMode? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.component5|component5(){}[0]
        final fun component6(): io.ktor.client.webrtc/WebRTCMedia.ResizeMode? // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.component6|component6(){}[0]
        final fun copy(kotlin/Int? = ..., kotlin/Int? = ..., kotlin/Int? = ..., kotlin/Double? = ..., io.ktor.client.webrtc/WebRTCMedia.FacingMode? = ..., io.ktor.client.webrtc/WebRTCMedia.ResizeMode? = ...): io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.copy|copy(kotlin.Int?;kotlin.Int?;kotlin.Int?;kotlin.Double?;io.ktor.client.webrtc.WebRTCMedia.FacingMode?;io.ktor.client.webrtc.WebRTCMedia.ResizeMode?){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.client.webrtc/WebRTCMedia.VideoTrackConstraints.toString|toString(){}[0]
    }
}

final fun <#A: io.ktor.client.webrtc/WebRTCConfig> io.ktor.client.webrtc/WebRTCClient(io.ktor.client.webrtc/WebRTCClientEngineFactory<#A>, kotlin/Function1<#A, kotlin/Unit> = ...): io.ktor.client.webrtc/WebRTCClient // io.ktor.client.webrtc/WebRTCClient|WebRTCClient(io.ktor.client.webrtc.WebRTCClientEngineFactory<0:0>;kotlin.Function1<0:0,kotlin.Unit>){0<io.ktor.client.webrtc.WebRTCConfig>}[0]
