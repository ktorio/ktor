// Klib ABI Dump
// Targets: [androidNativeArm32, androidNativeArm64, androidNativeX64, androidNativeX86, iosArm64, iosSimulatorArm64, iosX64, js, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, wasmJs, watchosArm32, watchosArm64, watchosDeviceArm64, watchosSimulatorArm64, watchosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <io.ktor:ktor-server-routing-annotate>
abstract fun interface io.ktor.annotate/OperationMapping { // io.ktor.annotate/OperationMapping|null[0]
    abstract fun map(io.ktor.openapi/Operation): io.ktor.openapi/Operation // io.ktor.annotate/OperationMapping.map|map(io.ktor.openapi.Operation){}[0]
    open fun plus(io.ktor.annotate/OperationMapping): io.ktor.annotate/OperationMapping // io.ktor.annotate/OperationMapping.plus|plus(io.ktor.annotate.OperationMapping){}[0]
}

sealed interface io.ktor.annotate/OpenApiDocSource { // io.ktor.annotate/OpenApiDocSource|null[0]
    final class FileSource : io.ktor.annotate/OpenApiDocSource { // io.ktor.annotate/OpenApiDocSource.FileSource|null[0]
        constructor <init>(kotlin/String) // io.ktor.annotate/OpenApiDocSource.FileSource.<init>|<init>(kotlin.String){}[0]

        final val contentType // io.ktor.annotate/OpenApiDocSource.FileSource.contentType|{}contentType[0]
            final fun <get-contentType>(): io.ktor.http/ContentType // io.ktor.annotate/OpenApiDocSource.FileSource.contentType.<get-contentType>|<get-contentType>(){}[0]
        final val path // io.ktor.annotate/OpenApiDocSource.FileSource.path|{}path[0]
            final fun <get-path>(): kotlin/String // io.ktor.annotate/OpenApiDocSource.FileSource.path.<get-path>|<get-path>(){}[0]

        final fun component1(): kotlin/String // io.ktor.annotate/OpenApiDocSource.FileSource.component1|component1(){}[0]
        final fun copy(kotlin/String = ...): io.ktor.annotate/OpenApiDocSource.FileSource // io.ktor.annotate/OpenApiDocSource.FileSource.copy|copy(kotlin.String){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.annotate/OpenApiDocSource.FileSource.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.annotate/OpenApiDocSource.FileSource.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.annotate/OpenApiDocSource.FileSource.toString|toString(){}[0]
    }

    final class FirstOf : io.ktor.annotate/OpenApiDocSource { // io.ktor.annotate/OpenApiDocSource.FirstOf|null[0]
        constructor <init>(kotlin.collections/List<io.ktor.annotate/OpenApiDocSource>) // io.ktor.annotate/OpenApiDocSource.FirstOf.<init>|<init>(kotlin.collections.List<io.ktor.annotate.OpenApiDocSource>){}[0]
        constructor <init>(kotlin/Array<out io.ktor.annotate/OpenApiDocSource>...) // io.ktor.annotate/OpenApiDocSource.FirstOf.<init>|<init>(kotlin.Array<out|io.ktor.annotate.OpenApiDocSource>...){}[0]

        final val options // io.ktor.annotate/OpenApiDocSource.FirstOf.options|{}options[0]
            final fun <get-options>(): kotlin.collections/List<io.ktor.annotate/OpenApiDocSource> // io.ktor.annotate/OpenApiDocSource.FirstOf.options.<get-options>|<get-options>(){}[0]

        final fun component1(): kotlin.collections/List<io.ktor.annotate/OpenApiDocSource> // io.ktor.annotate/OpenApiDocSource.FirstOf.component1|component1(){}[0]
        final fun copy(kotlin.collections/List<io.ktor.annotate/OpenApiDocSource> = ...): io.ktor.annotate/OpenApiDocSource.FirstOf // io.ktor.annotate/OpenApiDocSource.FirstOf.copy|copy(kotlin.collections.List<io.ktor.annotate.OpenApiDocSource>){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.annotate/OpenApiDocSource.FirstOf.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.annotate/OpenApiDocSource.FirstOf.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.annotate/OpenApiDocSource.FirstOf.toString|toString(){}[0]
    }

    final class OpenApiDocText : io.ktor.annotate/OpenApiDocSource { // io.ktor.annotate/OpenApiDocSource.OpenApiDocText|null[0]
        constructor <init>(kotlin/String, io.ktor.http/ContentType = ...) // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.<init>|<init>(kotlin.String;io.ktor.http.ContentType){}[0]

        final val content // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.content|{}content[0]
            final fun <get-content>(): kotlin/String // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.content.<get-content>|<get-content>(){}[0]
        final val contentType // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.contentType|{}contentType[0]
            final fun <get-contentType>(): io.ktor.http/ContentType // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.contentType.<get-contentType>|<get-contentType>(){}[0]

        final fun component1(): kotlin/String // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.component1|component1(){}[0]
        final fun component2(): io.ktor.http/ContentType // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.component2|component2(){}[0]
        final fun copy(kotlin/String = ..., io.ktor.http/ContentType = ...): io.ktor.annotate/OpenApiDocSource.OpenApiDocText // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.copy|copy(kotlin.String;io.ktor.http.ContentType){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.annotate/OpenApiDocSource.OpenApiDocText.toString|toString(){}[0]
    }

    final class RoutingSource : io.ktor.annotate/OpenApiDocSource { // io.ktor.annotate/OpenApiDocSource.RoutingSource|null[0]
        constructor <init>(io.ktor.http/ContentType = ..., io.ktor.openapi/JsonSchemaInference? = ..., kotlin/Function1<io.ktor.server.application/Application, kotlin.sequences/Sequence<io.ktor.server.routing/Route>> = ...) // io.ktor.annotate/OpenApiDocSource.RoutingSource.<init>|<init>(io.ktor.http.ContentType;io.ktor.openapi.JsonSchemaInference?;kotlin.Function1<io.ktor.server.application.Application,kotlin.sequences.Sequence<io.ktor.server.routing.Route>>){}[0]

        final val contentType // io.ktor.annotate/OpenApiDocSource.RoutingSource.contentType|{}contentType[0]
            final fun <get-contentType>(): io.ktor.http/ContentType // io.ktor.annotate/OpenApiDocSource.RoutingSource.contentType.<get-contentType>|<get-contentType>(){}[0]
        final val routes // io.ktor.annotate/OpenApiDocSource.RoutingSource.routes|{}routes[0]
            final fun <get-routes>(): kotlin/Function1<io.ktor.server.application/Application, kotlin.sequences/Sequence<io.ktor.server.routing/Route>> // io.ktor.annotate/OpenApiDocSource.RoutingSource.routes.<get-routes>|<get-routes>(){}[0]
        final val schemaInference // io.ktor.annotate/OpenApiDocSource.RoutingSource.schemaInference|{}schemaInference[0]
            final fun <get-schemaInference>(): io.ktor.openapi/JsonSchemaInference? // io.ktor.annotate/OpenApiDocSource.RoutingSource.schemaInference.<get-schemaInference>|<get-schemaInference>(){}[0]

        final fun component1(): io.ktor.http/ContentType // io.ktor.annotate/OpenApiDocSource.RoutingSource.component1|component1(){}[0]
        final fun component2(): io.ktor.openapi/JsonSchemaInference? // io.ktor.annotate/OpenApiDocSource.RoutingSource.component2|component2(){}[0]
        final fun component3(): kotlin/Function1<io.ktor.server.application/Application, kotlin.sequences/Sequence<io.ktor.server.routing/Route>> // io.ktor.annotate/OpenApiDocSource.RoutingSource.component3|component3(){}[0]
        final fun copy(io.ktor.http/ContentType = ..., io.ktor.openapi/JsonSchemaInference? = ..., kotlin/Function1<io.ktor.server.application/Application, kotlin.sequences/Sequence<io.ktor.server.routing/Route>> = ...): io.ktor.annotate/OpenApiDocSource.RoutingSource // io.ktor.annotate/OpenApiDocSource.RoutingSource.copy|copy(io.ktor.http.ContentType;io.ktor.openapi.JsonSchemaInference?;kotlin.Function1<io.ktor.server.application.Application,kotlin.sequences.Sequence<io.ktor.server.routing.Route>>){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // io.ktor.annotate/OpenApiDocSource.RoutingSource.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // io.ktor.annotate/OpenApiDocSource.RoutingSource.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // io.ktor.annotate/OpenApiDocSource.RoutingSource.toString|toString(){}[0]
    }

    final object Companion { // io.ktor.annotate/OpenApiDocSource.Companion|null[0]
        final fun (io.ktor.server.application/Application).readOpenApiSource(io.ktor.annotate/OpenApiDocSource, io.ktor.openapi/OpenApiDoc): io.ktor.annotate/OpenApiDocSource.OpenApiDocText? // io.ktor.annotate/OpenApiDocSource.Companion.readOpenApiSource|readOpenApiSource@io.ktor.server.application.Application(io.ktor.annotate.OpenApiDocSource;io.ktor.openapi.OpenApiDoc){}[0]
    }
}

final class io.ktor.annotate/CollectSchemaReferences : io.ktor.annotate/OperationMapping { // io.ktor.annotate/CollectSchemaReferences|null[0]
    constructor <init>(kotlin/Function1<io.ktor.openapi/JsonSchema, kotlin/String?>) // io.ktor.annotate/CollectSchemaReferences.<init>|<init>(kotlin.Function1<io.ktor.openapi.JsonSchema,kotlin.String?>){}[0]

    final fun map(io.ktor.openapi/Operation): io.ktor.openapi/Operation // io.ktor.annotate/CollectSchemaReferences.map|map(io.ktor.openapi.Operation){}[0]
}

final val io.ktor.annotate/AuthSecuritySchemesAttributeKey // io.ktor.annotate/AuthSecuritySchemesAttributeKey|{}AuthSecuritySchemesAttributeKey[0]
    final fun <get-AuthSecuritySchemesAttributeKey>(): io.ktor.util/AttributeKey<kotlin.collections/Map<kotlin/String, io.ktor.openapi/SecurityScheme>> // io.ktor.annotate/AuthSecuritySchemesAttributeKey.<get-AuthSecuritySchemesAttributeKey>|<get-AuthSecuritySchemesAttributeKey>(){}[0]
final val io.ktor.annotate/EndpointAnnotationAttributeKey // io.ktor.annotate/EndpointAnnotationAttributeKey|{}EndpointAnnotationAttributeKey[0]
    final fun <get-EndpointAnnotationAttributeKey>(): io.ktor.util/AttributeKey<kotlin.collections/List<kotlin/Function1<io.ktor.openapi/Operation.Builder, kotlin/Unit>>> // io.ktor.annotate/EndpointAnnotationAttributeKey.<get-EndpointAnnotationAttributeKey>|<get-EndpointAnnotationAttributeKey>(){}[0]
final val io.ktor.annotate/JsonSchemaAttributeKey // io.ktor.annotate/JsonSchemaAttributeKey|{}JsonSchemaAttributeKey[0]
    final fun <get-JsonSchemaAttributeKey>(): io.ktor.util/AttributeKey<io.ktor.openapi/JsonSchemaInference> // io.ktor.annotate/JsonSchemaAttributeKey.<get-JsonSchemaAttributeKey>|<get-JsonSchemaAttributeKey>(){}[0]
final val io.ktor.annotate/PopulateMediaTypeDefaults // io.ktor.annotate/PopulateMediaTypeDefaults|{}PopulateMediaTypeDefaults[0]
    final fun <get-PopulateMediaTypeDefaults>(): io.ktor.annotate/OperationMapping // io.ktor.annotate/PopulateMediaTypeDefaults.<get-PopulateMediaTypeDefaults>|<get-PopulateMediaTypeDefaults>(){}[0]

final fun (io.ktor.server.application/Application).io.ktor.annotate/findSecuritySchemes(kotlin/Boolean = ...): kotlin.collections/Map<kotlin/String, io.ktor.openapi/ReferenceOr<io.ktor.openapi/SecurityScheme>>? // io.ktor.annotate/findSecuritySchemes|findSecuritySchemes@io.ktor.server.application.Application(kotlin.Boolean){}[0]
final fun (io.ktor.server.application/Application).io.ktor.annotate/findSecuritySchemesOrRefs(kotlin/Boolean = ...): kotlin.collections/Map<kotlin/String, io.ktor.openapi/ReferenceOr<io.ktor.openapi/SecurityScheme>>? // io.ktor.annotate/findSecuritySchemesOrRefs|findSecuritySchemesOrRefs@io.ktor.server.application.Application(kotlin.Boolean){}[0]
final fun (io.ktor.server.application/Application).io.ktor.annotate/registerApiKeySecurityScheme(kotlin/String? = ..., kotlin/String, io.ktor.openapi/SecuritySchemeIn, kotlin/String = ...) // io.ktor.annotate/registerApiKeySecurityScheme|registerApiKeySecurityScheme@io.ktor.server.application.Application(kotlin.String?;kotlin.String;io.ktor.openapi.SecuritySchemeIn;kotlin.String){}[0]
final fun (io.ktor.server.application/Application).io.ktor.annotate/registerBasicAuthSecurityScheme(kotlin/String? = ..., kotlin/String = ...) // io.ktor.annotate/registerBasicAuthSecurityScheme|registerBasicAuthSecurityScheme@io.ktor.server.application.Application(kotlin.String?;kotlin.String){}[0]
final fun (io.ktor.server.application/Application).io.ktor.annotate/registerBearerAuthSecurityScheme(kotlin/String? = ..., kotlin/String = ..., kotlin/String? = ...) // io.ktor.annotate/registerBearerAuthSecurityScheme|registerBearerAuthSecurityScheme@io.ktor.server.application.Application(kotlin.String?;kotlin.String;kotlin.String?){}[0]
final fun (io.ktor.server.application/Application).io.ktor.annotate/registerOAuth2SecurityScheme(kotlin/String? = ..., io.ktor.openapi/OAuthFlows, kotlin/String? = ...) // io.ktor.annotate/registerOAuth2SecurityScheme|registerOAuth2SecurityScheme@io.ktor.server.application.Application(kotlin.String?;io.ktor.openapi.OAuthFlows;kotlin.String?){}[0]
final fun (io.ktor.server.application/Application).io.ktor.annotate/registerOpenIdConnectSecurityScheme(kotlin/String? = ..., kotlin/String, kotlin/String? = ...) // io.ktor.annotate/registerOpenIdConnectSecurityScheme|registerOpenIdConnectSecurityScheme@io.ktor.server.application.Application(kotlin.String?;kotlin.String;kotlin.String?){}[0]
final fun (io.ktor.server.application/Application).io.ktor.annotate/registerSecurityScheme(kotlin/String?, io.ktor.openapi/SecurityScheme) // io.ktor.annotate/registerSecurityScheme|registerSecurityScheme@io.ktor.server.application.Application(kotlin.String?;io.ktor.openapi.SecurityScheme){}[0]
final fun (io.ktor.server.routing/Route).io.ktor.annotate/annotate(kotlin/Function1<io.ktor.openapi/Operation.Builder, kotlin/Unit>): io.ktor.server.routing/Route // io.ktor.annotate/annotate|annotate@io.ktor.server.routing.Route(kotlin.Function1<io.ktor.openapi.Operation.Builder,kotlin.Unit>){}[0]
final fun (kotlin.sequences/Sequence<io.ktor.server.routing/Route>).io.ktor.annotate/findPathItems(io.ktor.annotate/OperationMapping = ...): kotlin.collections/Map<kotlin/String, io.ktor.openapi/PathItem> // io.ktor.annotate/findPathItems|findPathItems@kotlin.sequences.Sequence<io.ktor.server.routing.Route>(io.ktor.annotate.OperationMapping){}[0]
final fun io.ktor.annotate/generateOpenApiDoc(io.ktor.openapi/OpenApiDoc, kotlin.sequences/Sequence<io.ktor.server.routing/Route>): io.ktor.openapi/OpenApiDoc // io.ktor.annotate/generateOpenApiDoc|generateOpenApiDoc(io.ktor.openapi.OpenApiDoc;kotlin.sequences.Sequence<io.ktor.server.routing.Route>){}[0]
